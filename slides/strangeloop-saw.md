% From Testing to Proof using Symbolic Execution
% Aaron Tomb
% September 28, 2017

# Agenda

* TODO: Installation (~15m)

* TODO: Basic Overview (~15m)

* TODO: Exercises (~20m)

* TODO: More Flexible Verification (~15m)

* TODO: Exercises (~20m)

* TODO: Composition (~15m)

* TODO: Exercises (~20m)

# Installing SAW Locally

* TODO: locally

* TODO: VM images

# What is SAW?

* TODO

# Property Based Testing

* TODO

# XOR Swap Example

* Say we're using the XOR-based trick for swapping values:

~~~~ .c
void swap_xor(uint32_t *x, uint32_t *y) {
    *x = *x ^ *y;
    *y = *x ^ *y;
    *x = *x ^ *y;
}
~~~~

* Focus on values, since that's where the tricky part are
    * Pointers used just so it can be a separate function

# A Specification for Swapping

~~~~ .c
void swap_direct(uint32_t *x, uint32_t *y) {
    uint32_t tmp;
    tmp = *y;
    *y = *x;
    *x = tmp;
}
~~~~

~~~~ .c
int swap_correct(uint32_t x, uint32_t y) {
    uint32_t x1 = x, x2 = x, y1 = y, y2 = y;
    swap_xor(&x1, &y1);
    swap_direct(&x2, &y2);
    return (x1 == x2 && y1 == y2);
}
~~~~

# Manual Swap Testing

~~~~ .c
int main() {
    assert(swap_correct(0, 0));
    assert(swap_correct(0, 1));
    assert(swap_correct(1, 0));
    assert(swap_correct(32, 76));
    assert(swap_correct(0xFFFFFFFF, 0));
    assert(swap_correct(0, 0xFFFFFFFF));
    assert(swap_correct(0xFFFFFFFF, 0xFFFFFFFF));
    return 0;
}
~~~~

# Random Swap Testing

~~~~ .c
int main() {
    for(int idx = 0; i < 100; i++) {
        uint32_t x = rand();
        uint32_t y = rand();
        assert(swap_correct(x, y));
    }
    return 0;
}
~~~~

# Translating Programs to Formulas

* $\lambda x.~x + 1$ is a function

    * takes an argument $x$, and returns $x + 1$

* `swap_xor`: $\lambda (x, y).~(x \oplus y \oplus x \oplus y \oplus y, x \oplus y \oplus y)$

    * but $x \oplus x \equiv 0$ and $x \oplus 0 \equiv x$

* `swap_direct`: $\lambda (x, y).~(y, x)$

* Translation achieved using a technique called *symbolic execution*

# SAT and SMT Solvers

* TODO: automated provers for mathematical theorems

    * Such as: $\forall x, y.~(x \oplus y \oplus x \oplus y \oplus y, x
      \oplus y \oplus y) \equiv (y, x)$

* SAT = Boolean SATisfiability

* SMT = Satisfiability Modulo Theories

* Almost magic for what they can do, SAT can deal with things like:

    * Fixed-size bit vectors (even multiplication, but slowly)
    
    * Bit manipulation operations (and, or, xor, shifts)
    
    * Arrays of fixed sizes
    
    * Conditionals

* SMT adds things like:

    * Linear arithmetic on integers (addition, subtraction, multiplication by constants)

    * Arrays of arbitrary size

# Verifying Swap Correctness

~~~~
// Load the bitcode file generated by Clang.
swapmod <- llvm_load_module "swap.bc";

// Extract a formal model of `swap_correct`.
harness <- llvm_extract swapmod "swap_correct" llvm_pure;

// Use ABC prover to show it always returns non-zero.
prove_print abc {{ \x y -> harness x y != 0 }};
~~~~

# FFS Example

~~~~ .c
uint32_t ffs_ref(uint32_t word) {
  if(!word) return 0;
  for(int c = 0, i = 0; c < 32; c++)
    if(((1 << i++) & word) != 0)
      return i;
  return 0;
}
~~~~

~~~~ .c
uint32_t ffs_imp(uint32_t i) {
  char n = 1;
  if (!(i & 0xffff)) { n += 16; i >>= 16; }
  if (!(i & 0x00ff)) { n +=  8; i >>=  8; }
  if (!(i & 0x000f)) { n +=  4; i >>=  4; }
  if (!(i & 0x0003)) { n +=  2; i >>=  2; }
  return (i) ? (n+((i+1) & 0x01)) : 0;
}
~~~~

# Manual FFS Testing

* TODO

~~~~ .c
int ffs_imp_correct(uint32_t x) {
    return ffs_imp(x) == ffs_ref(x);
}
~~~~

# Random FFS Testing

~~~~ .c
int main() {
    for(int idx = 0; i < 100; i++) {
        uint32_t x = rand();
        assert(ffs_imp_correct(x));
    }
    return 0;
}
~~~~

# Verifying FFS Harness

* TODO: llvm_extract

* TODO: prove_print

# Verifying FFS Without Wrapper

* TODO: llvm_extract

* TODO: prove_print

# Pointers: Verifying XOR Swap Without Wrapper

* TODO: llvm_verify

# More Complex Verifications, In General

* TODO: initialize state

* TODO: run target code

* TODO: check final state

# Composition: Verifying Salsa20

* TODO: show low-level function

* TODO: show one level on top of that

# Sidebar: Fuzzing for Property Based Tests

* TODO: mention libfuzzer

~~~~ .c
int LLVMFuzzerTestOneInput(const uint8_t *Data,
                           size_t Size) {
  DoSomethingInterestingWithMyAPI(Data, Size);
  return 0;  // Non-zero reserved for future use.
}

~~~~

# Sidebar: SAW on `libfuzzer` Harnesses

~~~~
let fuzzer_spec n = do {
    let ty = (llvm_array n (llvm_int 8));
    data <- crucible_fresh_var "data" ty;
    pdata <- crucible_alloc ty;
    crucible_points_to pdata (crucible_term data);
    crucible_execute_func
        [ pdata
        , crucible_term {{ `n : [64] }}
        ];
    crucible_return (crucible_term {{ 0 : [32] }});
};

m <- llvm_load_module "fuzztarget.bc";
crucible_llvm_verify m "LLVMFuzzerTestOneInput"
    [] false (fuzzer_spec 20) abc;
~~~~

# Other Ways to use SAT and SMT

* TODO

# Other Things Available in SAW

* TODO: Java

* TODO: Coming soon: Rust, Go, some degree of machine code

* TODO: more powerful interactive verification

* TODO: Coming soon: bindings to external interactive provers, including Lean and Coq

# How Much Can You Do?

* TODO

# Conclusion

* TODO
