% From Testing to Proof using Symbolic Execution
% Aaron Tomb
% September 28, 2017

# Agenda

* Installation (~15m)

* Basic overview (~15m)

* Exercises (~20m)

* More flexible verification (~15m)

* Exercises (~20m)

* Composition and more (~15m)

* Exercises (~20m)

# Installing SAW Locally

* TODO: locally

* TODO: VM images

# What is SAW?

* TODO: take from other presentations

# Property Based Testing

* TODO

# XOR Swap Example

* Say we're using the XOR-based trick for swapping values:

~~~~ .c
void swap_xor(uint32_t *x, uint32_t *y) {
  *x = *x ^ *y;
  *y = *x ^ *y;
  *x = *x ^ *y;
}
~~~~

* Focus on values, since that's where the tricky parts are
    * Pointers used just so it can be a separate function

# A Specification for Swapping

~~~~ .c
void swap_direct(uint32_t *x, uint32_t *y) {
  uint32_t tmp;
  tmp = *y;
  *y = *x;
  *x = tmp;
}
~~~~

~~~~ .c
int swap_correct(uint32_t x, uint32_t y) {
  uint32_t x1 = x, x2 = x, y1 = y, y2 = y;
  swap_xor(&x1, &y1);
  swap_direct(&x2, &y2);
  return (x1 == x2 && y1 == y2);
}
~~~~

# Manual Swap Testing

~~~~ .c
int main() {
  assert(swap_correct(0, 0));
  assert(swap_correct(0, 1));
  assert(swap_correct(1, 0));
  assert(swap_correct(32, 76));
  assert(swap_correct(0xFFFFFFFF, 0));
  assert(swap_correct(0, 0xFFFFFFFF));
  assert(swap_correct(0xFFFFFFFF, 0xFFFFFFFF));
  return 0;
}
~~~~

* TODO: points about pros and cons

# Random Swap Testing

~~~~ .c
int main() {
  for(int idx = 0; i < 100; i++) {
    uint32_t x = rand();
    uint32_t y = rand();
    assert(swap_correct(x, y));
  }
  return 0;
}
~~~~

* TODO: points about pros and cons

# Translating Programs to Formulas

* $\lambda x.~x + 1$ is a function

    * takes an argument $x$, and returns $x + 1$

* `swap_xor`: $\lambda (x, y).~(x \oplus y \oplus x \oplus y \oplus y, x \oplus y \oplus y)$

    * but $x \oplus x \equiv 0$ and $x \oplus 0 \equiv x$

* `swap_direct`: $\lambda (x, y).~(y, x)$

* Translation achieved using a technique called *symbolic execution*

    * TODO: more

# SAT and SMT Solvers

* TODO: automated provers for mathematical theorems

    * Such as: $\forall x, y.~(x \oplus y \oplus x \oplus y \oplus y, x
      \oplus y \oplus y) \equiv (y, x)$

* SAT = Boolean SATisfiability

* SMT = Satisfiability Modulo Theories

* Almost magic for what they can do, SAT can deal with things like:

    * Fixed-size bit vectors (even multiplication, but slowly)
    
    * Bit manipulation operations (and, or, xor, shifts)
    
    * Arrays of fixed sizes
    
    * Conditionals

* SMT adds things like:

    * Linear arithmetic on integers (addition, subtraction, multiplication by constants)

    * Arrays of arbitrary size

# Verifying Swap Correctness

~~~~
// Load the bitcode file generated by Clang.
swapmod <- llvm_load_module "swap.bc";

// Extract a formal model of `swap_correct`.
harness <- llvm_extract swapmod "swap_correct" llvm_pure;

// Use ABC prover to show it always returns non-zero.
prove_print abc {{ \x y -> harness x y != 0 }};
~~~~

# FFS Example

~~~~ .c
uint32_t ffs_ref(uint32_t word) {
  if(!word) return 0;
  for(int c = 0, i = 0; c < 32; c++)
    if(((1 << i++) & word) != 0)
      return i;
  return 0;
}
~~~~

~~~~ .c
uint32_t ffs_imp(uint32_t i) {
  char n = 1;
  if (!(i & 0xffff)) { n += 16; i >>= 16; }
  if (!(i & 0x00ff)) { n +=  8; i >>=  8; }
  if (!(i & 0x000f)) { n +=  4; i >>=  4; }
  if (!(i & 0x0003)) { n +=  2; i >>=  2; }
  return (i) ? (n+((i+1) & 0x01)) : 0;
}
~~~~

# Manual FFS Testing

* TODO: describe

~~~~ .c
int ffs_imp_correct(uint32_t x) {
  return ffs_imp(x) == ffs_ref(x);
}
~~~~

* TODO: list specific tests

# Random FFS Testing

* TODO: describe

~~~~ .c
int main() {
  for(int idx = 0; i < 100; i++) {
    uint32_t x = rand();
    assert(ffs_imp_correct(x));
  }
  return 0;
}
~~~~

# Verifying FFS Harness

* TODO: llvm_extract

* TODO: prove_print

# Verifying FFS Without Wrapper

* TODO: llvm_extract of ffs_ref

* TODO: llvm_verify of ffs_imp

# Pointers: Verifying XOR Swap Without Wrapper

* TODO: llvm_verify, ptr_to_fresh

# More Complex Verifications, In General

* Verifications in SAW consist of three phases

    * Initialize a starting state

    * Run the target code in that state

    * Check that the final state is correct

* Commands like `llvm_extract` just simplify a common case

* When running the target code, we can sometimes use previously-proven
  facts about code it calls

# Composition: Verifying Salsa20 (C code)

~~~~ .c
static void s20_quarterround(uint32_t *y0, uint32_t *y1,
                             uint32_t *y2, uint32_t *y3)
{
  *y1 = *y1 ^ rotl(*y0 + *y3, 7);
  *y2 = *y2 ^ rotl(*y1 + *y0, 9);
  *y3 = *y3 ^ rotl(*y2 + *y1, 13);
  *y0 = *y0 ^ rotl(*y3 + *y2, 18);
}

static void s20_rowround(uint32_t y[static 16])
{
  s20_quarterround(&y[0], &y[1], &y[2], &y[3]);
  s20_quarterround(&y[5], &y[6], &y[7], &y[4]);
  s20_quarterround(&y[10], &y[11], &y[8], &y[9]);
  s20_quarterround(&y[15], &y[12], &y[13], &y[14]);
}
~~~~

# Composition: Verifying Salsa20 (SAW code)

~~~~
let quarterround_setup : CrucibleSetup () = do {
  (p0, y0) <- ptr_to_fresh "y0" i32;
  // ... and three more
  crucible_execute_func [p0, p1, p2, p3];
  let zs = {{ quarterround [y0,y1,y2,y3] }};
  crucible_points_to p0 (crucible_term {{ zs@0 }});
    // ... and three more
};

let rowround_setup = do {
  (y, p) <- ptr_to_fresh "y" (llvm_array 16 i32);
  crucible_execute_func [p];
  crucible_points_to p (crucible_term {{ rowround x }});
};
~~~~

# Sidebar: Fuzzing for Property Based Tests

* TODO: mention libfuzzer

~~~~ .c
int LLVMFuzzerTestOneInput(const uint8_t *Data,
                           size_t Size) {
  DoSomethingInterestingWithMyAPI(Data, Size);
  return 0;  // Non-zero reserved for future use.
}

~~~~

# Sidebar: SAW on `libfuzzer` Harnesses

~~~~
let fuzzer_spec n = do {
  let ty = llvm_array n i8;
  (pdata, data) <- ptr_to_fresh "data" ty;
  crucible_execute_func
    [ pdata
    , crucible_term {{ `n : [64] }}
    ];
  crucible_return (crucible_term {{ 0 : [32] }});
};

m <- llvm_load_module "fuzztarget.bc";
for [1, 10, 20, 100] (\sz ->
  crucible_llvm_verify m "LLVMFuzzerTestOneInput"
    [] true (fuzzer_spec n) abc);
~~~~

# Other Ways to use SAT and SMT

* TODO: Interfaces

    * TODO: Cryptol

    * TODO: SBV

    * TODO: Rise4Fun

    * TODO: Python Z3 bindings

* TODO: examples of use cases

    * TODO

# Other Things Available in SAW

* TODO: Java

* TODO: Coming soon: Rust, Go, some degree of machine code

* TODO: more powerful interactive verification

* TODO: Coming soon: bindings to external interactive provers, including Lean and Coq

# How Much Can You Do?

* TODO

# Final Points

* TODO: pointers

    * TODO: saw.galois.com
    
    * TODO: cryptol.net
    
    * TODO: manuals

* TODO: where to go from here

* I'll be around all day, and happy to talk more!
